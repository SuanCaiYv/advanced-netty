## 部分原理

### TCP长连接

#### 实现原理

TCP长连接的实现有两种方式：操作系统实现、应用层实现。

**操作系统实现**

操作系统实现方式比较单一，即通过内核来进行TCP的保活。

操作系统实现TCP保活基本过程如下：

 * 如果某个连接在一定时间内(视系统配置文件决定，一般是7500s)没有数据传输，那么会发送KeepAlive探针进行探测。
 * 如果远程节点超时未响应，则重试指定次数(视配置文件决定，一般是10次)，每次间隔指定时间(视配置文件决定，一般是75s)，如果最后还是没有回应，则关闭连接。

这个配置文件一般是/etc/sysctl.conf。

其实这里我们已经发现了一些问题，比如只有链路空闲，没有数据传输才会触发保活，以及假死判定等。

**应用层实现**

应用层实现比较朴素，即发送心跳包(一种特殊的请求)进行探测，不同的框架和设计可能在实现上各有不同，但是大致都是通过间隔一定时间发送心跳包，检测响应值来实现。

其基本实现可以是这样的：

 * 每隔一定时间发送一个心跳包，如果收到响应则视为连接存活，否则进入重发阶段。
 * 如果某次心跳包无法得到响应，或响应超时，便进入快速重试阶段，此时心跳包发送的速度会变快；当超过一定次数依旧失败后，视为连接断开。此时如果是服务端可以直接关闭连接，客户端则可以尝试重新建立连接。

其实应用层保活有四种情况：

 * 正常。心跳包发送，得到响应。
 * 异常。远程节点宕机，无法响应所有心跳包。
 * 异常。远程节点宕机重启，收到部分心跳包，此时触发重置操作，告诉发送方应该中断连接。
 * 异常。远程节点发现应用不可达，即第二种的角色互换版。

此外，关于应用层心跳包的时间间隔设置，重试设置(也可以不缩短重试间隔)，都是需要考虑的。而且我们需要保证心跳包只能在空闲时发送，同时需要考虑区分心跳包和业务包。因为操作系统层次的心跳包属于内核维护，对应用不可见，所以没有这一负担。

关于如何选择的问题，一般来说我们需要实现自己的应用层保活机制，为什么呢？

首先，内核维护的心跳包更改配置需要更改系统配置文件，比较麻烦。

其次，内核维护的心跳包当发生物理链路中断时，会触发超时重传机制，这是一笔不小的损耗，对于实时系统可能无法接受。

最后，对于被测方，如果是因为负载过大而导致无法响应，我们应该视为它发生了假死，因为此时连接是可达的，内核会认为没有发生异常，请求继续，但是服务可能马上就要崩了。对于这种服务假死，我们只能用应用层来实现。

更好地实现是二者结合，互相补充。
## 部分原理

### TCP长连接

#### 实现原理

TCP长连接的实现有两种方式：操作系统实现、应用层实现。

**操作系统实现**

操作系统实现方式比较单一，即通过内核来进行TCP的保活。

操作系统实现TCP保活基本过程如下：

 * 如果某个连接在一定时间内(视系统配置文件决定，一般是7500s)没有数据传输，那么会发送KeepAlive探针进行探测。
 * 如果远程节点超时未响应，则重试指定次数(视配置文件决定，一般是10次)，每次间隔指定时间(视配置文件决定，一般是75s)，如果最后还是没有回应，则关闭连接。

这个配置文件一般是/etc/sysctl.conf。

其实这里我们已经发现了一些问题，比如只有链路空闲，没有数据传输才会触发保活，以及假死判定等。

**应用层实现**

应用层实现比较朴素，即发送心跳包(一种特殊的请求)进行探测，不同的框架和设计可能在实现上各有不同，但是大致都是通过间隔一定时间发送心跳包，检测响应值来实现。

其基本实现可以是这样的：

 * 每隔一定时间发送一个心跳包，如果收到响应则视为连接存活，否则进入重发阶段。
 * 如果某次心跳包无法得到响应，或响应超时，便进入快速重试阶段，此时心跳包发送的速度会变快；当超过一定次数依旧失败后，视为连接断开。此时如果是服务端可以直接关闭连接，客户端则可以尝试重新建立连接。

其实应用层保活有四种情况：

 * 正常。心跳包发送，得到响应。
 * 异常。远程节点宕机，无法响应所有心跳包。
 * 异常。远程节点宕机重启，收到部分心跳包，此时触发重置操作，告诉发送方应该中断连接。
 * 异常。远程节点发现应用不可达，即第二种的角色互换版。

此外，关于应用层心跳包的时间间隔设置，重试设置(也可以不缩短重试间隔)，都是需要考虑的。而且我们需要保证心跳包只能在空闲时发送，同时需要考虑区分心跳包和业务包。因为操作系统层次的心跳包属于内核维护，对应用不可见，所以没有这一负担。

关于如何选择的问题，一般来说我们需要实现自己的应用层保活机制，为什么呢？

首先，内核维护的心跳包更改配置需要更改系统配置文件，比较麻烦。

其次，内核维护的心跳包当发生物理链路中断时，会触发超时重传机制，这是一笔不小的损耗，对于实时系统可能无法接受。

最后，对于被测方，如果是因为负载过大而导致无法响应，我们应该视为它发生了假死，因为此时连接是可达的，内核会认为没有发生异常，请求继续，但是服务可能马上就要崩了。对于这种服务假死，我们只能用应用层来实现。

更好地实现是二者结合，互相补充。

此外，Http的长连接短连接对应于TCP的长短连接，我们引入Http的长短连接是为了在一次连接上进行多次请求，而不是TCP的保活机制，那是**两码事**。

如果非要说TCP保活的应用的话，那就是WebSocket协议。

我们在这里提一个优化技巧，就是业务数据包可以做为心跳包来使用，当没有业务数据时，才发送心跳包进行探测。

### WebSocket/Http

WebSocket**主要用于网页端**！这是很重要的一点。为什么我要这么强调呢？首先来看一个场景：

 * 我们有一个网站，算了就比如推特吧！需要当用户登录之后，实现对用户的推送功能，就是发生了热点事件，能让右上角的小铃铛冒红，里面包含了热点事件。
 * 如果是移动端，或者Client可能很好解决，我们弄一个常驻后台的接收推送线程，然后开启**TCP长连接**，这样就可以实现长时间的全双工通信了，服务端就可以通过这个长连接主动发起消息。至于为什么用长连接是因为消息推送是持久的，我们不知道消息什么时候产生，而且客户端IP是可变的，我们无法主动连接它们，所以要抓住和它们连接之后的通道，也就是这个长连接，然后进行操作。
 * 但是如果是网页怎么办？浏览器**不允许应用自行建立TCP长连接**，那样就乱套了。而Http是典型的**一问一答**，就像直男聊天一样，“吃了吗？”，“吃了”；“在干嘛？”，“玩手机”。所以身为服务器的我们无法主动发起请求(推送)，而WebSocket就是为了实现这一功能出现的，使得双端可以互相主动发送消息。

说个题外话，Http之所以设计成短连接是为了节省资源，因为维护一个连接需要内存成本的，后来发现应用追求速度，内存越来越便宜，而每次建立连接的时间又太长了，索性进行了优化，就是**Keep-Alive**参数。但是，此时Http依旧是一问一答的，只是这一问一答不再是一问一次连接，而是**多问一次连接**。

所以这里我们可以看到，Http1.0就是阉割版的TCP应用协议，WebSocket就是满血版的TCP应用协议。